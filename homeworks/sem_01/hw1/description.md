# Домашнее задание 1

## Порядок оценивания

- Работу необходимо сдать в срок, установленный семинаристом, иначе работа будет оценена в 0;
- Работа должна быть хорошо оформлена: все объекты должны быть именованы в соответствии с соглашениями Python, все имена должны быть осмыслены и понятны, между операторами должны находится отступы и т.д.. Проверка оформления будет осуществляться с помощью [`flake8`](https://flake8.pycqa.org/en/latest/). Конфигурация `flake8`, которая будет использована для проверки находится в корне репозитория в файле [`.flake8`](./../../../.flake8);
- Реализация должна быть корректной и проходить все закрытые тесты. За неверно пройденный тест работа будет аннулирована, так что внимательно подойдите к процессу самопроверки.
- Если вы будете уличены в списывании или пособничестве списыванию, ваша работа аннулируется;
- Вы должны будете защитить работу на устной сдаче семинаристу, рассказав решение и ответив на все вопросы;
- Итоговая оценка ставится после итоговой устной сдачи семинаристу. При выставлении итоговой оценки семинарист учитывает все пункты, озвученные выше.

## Задача 1. DAU, WAU, MAU

**Задача**

В коммерческой разработки существует большое количество различных метрик, позволяющих отслеживать активность пользователей. Одними из таких метрик являются метрики **Day Active Users** (DAU), **Week Active Users** (WAU) и **Month Active Users** (MAU) - число активных пользователей за определенный промежуток времени (день, неделю и месяц, соответственно). Под активными пользователями понимаются уникальные пользователи, которые пользовались нашим продуктом хотя бы один раз в обозначенный период времени. Важно, что пользователи являются уникальными. Т.е. если мы измеряем **DAU** и в течении текущего дня нашим приложеним пользовался один и тот же пользователь пусть и несколько раз, **DAU** будет равно 1.

Логика расчета метрик **DAU**, **WAU** и **MAU** совпадает, отличается лишь число дней, для которого происходит накопление уникальных пользователей. Обобщая эту логику еще сильнее, мы можем реализовать специальный объект, с помощью которого мы бы имели возможность подсчитывать число активных пользователей нашего продукта за произвольный промежуток времени. Ваша задача - реализовать такой объект.

В файле [`metrics.py`](./metrics.py) содержится заготовка класса `PeriodActiveUsers`. Именно этот класс мы будем использовать для расчета числа активных пользователей за определенный период времени. Приведем некоторые требования к функционалу класса:
- `Инициализация`. При создании экземпляра класса `PeriodActiveUsers` пользователю необходимо передать параметр `accumulation_period` - период времени, для которого будет вычисляться число уникальных пользователей. Ожидается, что `accumulation_period` будет целым числом, большим единицы, однако допустимо передавать любой объект, который может быть округлен и преобразован в целое число с помощью вызова встроенной функции `round()`. Если переданный объект несовместим с вызовом функции `round()`, необходимо возбудить исключение `TypeError`. Если после использования функции `round()` с переданным объектом было получено число, меньшее 1, необходимо возбудить исключение `ValueError`.
- `add_active_users_for_curr_day()`. С помощью этого метода вы можете передать последовательность `UUID` пользователей, которые пользовались сервисом в текущий день.
- `unique_users_amount`, атрибут, в котором хранится число уникальных пользовотелей, посещавших наш ресурс за последние `accumulation_period` дней. Иначе говоря, в атрибуте `unique_users_amount` хранится актуальное значение метрики.
- `accumulation_period`, атрибут, период времени, для которого будет вычисляться число уникальных пользователей.

**Примеры использования**

**Пример 1**
```python
from uuid import UUID
from metrics import PeriodActiveUsers


pau = PeriodActiveUsers(accumulation_period=1)
pau.add_active_users_for_curr_day(
    [
        UUID("2509a9eb-2422-4b83-8911-f780eea815bb"),
        UUID("f52fc9b2-2ff2-4419-9f07-22267946b46e"),
    ],
)
assert pau.unique_users_amount == 2
```

**Пример 2**
```python
from uuid import UUID
from metrics import PeriodActiveUsers


pau = PeriodActiveUsers(accumulation_period=3)
pau.add_active_users_for_curr_day(
    [
        UUID("52d6f353-4dd3-421b-b1c4-c35d2ae9ad66"),
        UUID("3f06aef7-bf3a-41f8-b571-3453a3b27aa9"),
        UUID("b6595baa-a23a-4e22-8656-079f84c7c3a4"),
        UUID("52d6f353-4dd3-421b-b1c4-c35d2ae9ad66"),
        UUID("52d6f353-4dd3-421b-b1c4-c35d2ae9ad66"),
        UUID("b6595baa-a23a-4e22-8656-079f84c7c3a4"),
    ],
)
assert pau.unique_users_amount == 3
```

**Вопросы для размышления**

- Почему мы используем именно класс для реализации данного функционала? Возможно ли сделать это иначе?
- Что является состоянием объекта для подсчета метрики?

## Задача 2. LRU

**Задача**

Выполнение некоторых алгоритмов, даже при учете оптимальной реализации, может потребовать большого количества времени, а поэтому вычисления, реализуемые с помощью данного алгоритма, будут стоить очень дорого (и в смысле времени, и в смысле денежных средств). Можно попытаться решить эту проблему несколькими способами. Например, можно попытаться оптимизировать реализацию алгоритма, в надеже на то, что это сильно увеличит быстродействие. Однако, далеко не всегда это возможно. Поэтому инженерное сообщество стало думать о том, как уменьшить расходы на вычисления путем сокращения вызовов функций.

Самый простой способ реализации такого подхода - словарь, который бы хранил пары вида `{func_agrs: func_result}`. Тогда при вызове вычислительно дорогой функции, мы сначала проверим, есть ли результат вычисления данной функции с переданными параметрами в словаре, и если он есть - просто вернем это значение. Если результата нет, то нам придется вычислить его, а затем поместить в словарь, чтобы при последующих вызовах функции с данными парамерами, нам бы не пришлось выполнять уже проделанные вычисления.

Однако, данный подход обладает существенным минусом - бесконечный рост словаря. Именно поэтому инженерное сообщество пыталось придумать эффективный способ ограничения числа запоминаемых значений. Один из таких способо - это алгоритм `LRU cache`. **LRU** - сокращение от английского *Least Recent Used*. Идейно алгоритм работает следующим образом:
- у нас имеется некоторый словарь ограниченного размера;
- у каждой пары есть в словаре есть свой приоритет на удаление: чем дольше не использовалась какая-либо пара, тем больше ее приоритет на удаление;
- если для данного набора параметров, переданных во время вызова функции, в словаре имеются данные, то мы используем данные для словаря и понижаем приоритет на удаление использованной пары;
- если для данного набора параметров, переданных во время вызова функции, в словаре нет данных, то мы вызываем саму функцию, а результат сохраняем в словарь с наименьшим приоритетом на удаление;
- если размер словаря превышает установленные ограничения, мы удаляем из него пару с наибольшим приоритетом на удаление;

Логика в том, что мы пытаемся сохранить в словаре часто используемые значения, и избавиться от редкоиспользуемых. Отсюда и название алгоритма.

Итак, ваша задача - реализовать алгоритм `LRU cache` в виде параметризованного декоратора `lru_cache` для реализации возможность добавления кеша к различным функциям.

Параметом декаратора является целое число `capacity` - максимально возможный размер кеша. Ожидается, что `capacity` будет целым числом, большим единицы, однако допустимо передавать любой объект, который может быть округлен и преобразован в целое число с помощью вызова встроенной функции `round()`. Если переданный объект несовместим с вызовом функции `round()`, необходимо возбудить исключение `TypeError`. Если после использования функции `round()` с переданным объектом было получено число, меньшее 1, необходимо возбудить исключение `ValueError`.

**ВАЖНО**: в Python существует готовый декоратор `lru_cache`, который находится в модуле `functools`. Использование этого декоратора, как и любых других готовых решений - **ЗАПРЕЩЕНО**. Такие решения будут оценены в 0 баллов. Вам необходимо реализовать алгоритм **САМОСТОЯТЕЛЬНО**.

**Пример использования**

```python
from cache import lru_cache


@lru_cache(capacity=2)
def get_greeting(name: str) -> str:
    greeting = f"Hello, {name}!"
    print(f"call func for name: {name}")

    return greeting


print(get_greeting("Mr.White"))
print(get_greeting("Mike"))
print(get_greeting("Mr.White"))
print(get_greeting("Saul Goodman"))
print(get_greeting("Mr.White"))
print(get_greeting("Mike"))
```

**Вывод**
```console
call func for name: Mr.White
Hello, Mr.White!
call func for name: Mike
Hello, Mike!
Hello, Mr.White!
call func for name: Saul Goodman
Hello, Saul Goodman!
Hello, Mr.White!
call func for name: Mike
Hello, Mike!
```
